// =============================================================================
// üåç WOLOFDICT - APPLICATION PRINCIPALE
// Fichier : backend/src/app.js
// Description : Point d'entr√©e de l'application Express avec syst√®me business
// =============================================================================

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const morgan = require('morgan');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config();

// =============================================================================
// üîß IMPORTS LOCAUX
// =============================================================================

// Configuration
const { sequelize } = require('./models');
const logger = require('./utils/logger');

// Routes
const routes = require('./routes');

// Middlewares
const { authenticateToken, optionalAuth } = require('./middleware/auth');
const { errorHandler } = require('./middleware/errorHandler');
const { requestLogger } = require('./middleware/requestLogger');

// Services
const RedisService = require('./services/RedisService');
const EmailService = require('./services/EmailService');
const StripeService = require('./services/business/StripeService');

// =============================================================================
// üöÄ CR√âATION DE L'APPLICATION
// =============================================================================

const app = express();

// Assignation d'un ID unique √† chaque requ√™te
app.use((req, res, next) => {
  req.id = uuidv4();
  next();
});

// =============================================================================
// üõ°Ô∏è S√âCURIT√â ET MIDDLEWARES GLOBAUX
// =============================================================================

// Helmet pour s√©curit√© headers
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:"],
      scriptSrc: ["'self'"],
      connectSrc: ["'self'", "https://api.stripe.com"],
      mediaSrc: ["'self'", "https://wolofdict-audio.s3.amazonaws.com"]
    }
  },
  crossOriginEmbedderPolicy: false
}));

// CORS configuration
const corsOptions = {
  origin: (origin, callback) => {
    const allowedOrigins = [
      'http://localhost:3000',
      'http://localhost:3001',
      'https://wolofdict.com',
      'https://www.wolofdict.com',
      'https://app.wolofdict.com',
      'https://admin.wolofdict.com'
    ];

    // Permettre les requ√™tes sans origin (mobile apps, Postman, etc.)
    if (!origin) return callback(null, true);

    if (allowedOrigins.includes(origin) || process.env.NODE_ENV === 'development') {
      callback(null, true);
    } else {
      callback(new Error('Non autoris√© par CORS'));
    }
  },
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-API-Key']
};

app.use(cors(corsOptions));

// Compression des r√©ponses
app.use(compression({
  level: 6,
  threshold: 1024, // Seulement pour les r√©ponses > 1KB
  filter: (req, res) => {
    if (req.headers['x-no-compression']) return false;
    return compression.filter(req, res);
  }
}));

// =============================================================================
// üìä LOGGING ET MONITORING
// =============================================================================

// Morgan pour logging HTTP
app.use(morgan('combined', {
  stream: {
    write: (message) => {
      logger.info(message.trim());
    }
  }
}));

// Request logging personnalis√©
app.use(requestLogger);

// =============================================================================
// üîÑ PARSING ET MIDDLEWARE BODY
// =============================================================================

// Body parsing
app.use(express.json({ 
  limit: '10mb',
  verify: (req, res, buf) => {
    // Stocker le raw body pour les webhooks Stripe
    if (req.originalUrl.startsWith('/api/v1/webhooks/stripe')) {
      req.rawBody = buf;
    }
  }
}));

app.use(express.urlencoded({ 
  extended: true, 
  limit: '10mb' 
}));

// Parsing des cookies
app.use(require('cookie-parser')());

// =============================================================================
// üìà RATE LIMITING INTELLIGENT
// =============================================================================

// Rate limiting global bas√© sur le plan utilisateur
const intelligentRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: async (req) => {
    try {
      // R√©cup√©rer le plan utilisateur
      if (req.user?.plan?.slug === 'pro') return 10000;
      if (req.user?.plan?.slug === 'premium') return 5000;
      if (req.user?.plan?.slug === 'free') return 1000;
      
      // Utilisateur non connect√©
      return 500;
    } catch (error) {
      return 500; // Fallback conservateur
    }
  },
  message: (req) => ({
    error: 'Trop de requ√™tes',
    current_plan: req.user?.plan?.name || 'Anonyme',
    limit_info: 'Passez au plan Premium pour des limites plus √©lev√©es',
    retry_after: 900,
    upgrade_url: '/plans'
  }),
  standardHeaders: true,
  legacyHeaders: false,
  // Exclure les webhooks du rate limiting
  skip: (req) => req.originalUrl.startsWith('/api/v1/webhooks/')
});

// =============================================================================
// üéØ TRUST PROXY ET CONFIGURATION
// =============================================================================

// Trust proxy pour d√©ploiement derri√®re reverse proxy
app.set('trust proxy', 1);

// Configuration Express
app.set('x-powered-by', false);
app.set('json spaces', process.env.NODE_ENV === 'development' ? 2 : 0);

// =============================================================================
// üóÑÔ∏è CONNEXION BASE DE DONN√âES
// =============================================================================

// Test de connexion √† la base de donn√©es
const initializeDatabase = async () => {
  try {
    await sequelize.authenticate();
    logger.info('‚úÖ Connexion √† la base de donn√©es √©tablie');
    
    // Synchronisation des mod√®les (seulement en d√©veloppement)
    if (process.env.NODE_ENV === 'development') {
      await sequelize.sync({ alter: true });
      logger.info('‚úÖ Mod√®les synchronis√©s');
    }
    
    return true;
  } catch (error) {
    logger.error('‚ùå Erreur de connexion √† la base de donn√©es:', error);
    return false;
  }
};

// =============================================================================
// üî¥ CONNEXION REDIS
// =============================================================================

// Initialisation Redis pour cache et sessions
const initializeRedis = async () => {
  try {
    if (process.env.REDIS_URL) {
      await RedisService.connect();
      logger.info('‚úÖ Connexion Redis √©tablie');
      return true;
    } else {
      logger.warn('‚ö†Ô∏è Redis non configur√©, utilisation du cache m√©moire');
      return false;
    }
  } catch (error) {
    logger.error('‚ùå Erreur connexion Redis:', error);
    return false;
  }
};

// =============================================================================
// üí≥ INITIALISATION SERVICES BUSINESS
// =============================================================================

// Initialisation des services de paiement
const initializePaymentServices = async () => {
  try {
    // V√©rification Stripe
    if (process.env.STRIPE_SECRET_KEY) {
      await StripeService.initialize();
      logger.info('‚úÖ Service Stripe initialis√©');
    }
    
    // V√©rification PayPal
    if (process.env.PAYPAL_CLIENT_ID && process.env.PAYPAL_CLIENT_SECRET) {
      // Initialisation PayPal
      logger.info('‚úÖ Service PayPal initialis√©');
    }
    
    return true;
  } catch (error) {
    logger.error('‚ùå Erreur initialisation services paiement:', error);
    return false;
  }
};

// =============================================================================
// üìß INITIALISATION SERVICES COMMUNICATION
// =============================================================================

// Initialisation service email
const initializeEmailService = async () => {
  try {
    if (process.env.SMTP_HOST) {
      await EmailService.initialize();
      logger.info('‚úÖ Service email initialis√©');
      return true;
    } else {
      logger.warn('‚ö†Ô∏è Service email non configur√©');
      return false;
    }
  } catch (error) {
    logger.error('‚ùå Erreur initialisation service email:', error);
    return false;
  }
};

// =============================================================================
// üîí MIDDLEWARES D'AUTHENTIFICATION
// =============================================================================

// Middleware d'authentification optionnelle pour personnaliser l'exp√©rience
app.use('/api/v1', optionalAuth);

// Middleware pour attacher les informations du plan utilisateur
app.use('/api/v1', async (req, res, next) => {
  if (req.user) {
    try {
      const { Subscription, Plan } = require('./models');
      
      // R√©cup√©rer l'abonnement actuel
      const subscription = await Subscription.findOne({
        where: { 
          user_id: req.user.id,
          status: ['active', 'trialing', 'past_due']
        },
        include: [{ model: Plan, as: 'plan' }]
      });

      if (subscription) {
        req.user.plan = subscription.plan;
        req.user.subscription = subscription;
      } else {
        // Plan gratuit par d√©faut
        req.user.plan = await Plan.findOne({ where: { slug: 'free' } });
      }
    } catch (error) {
      logger.error('Erreur r√©cup√©ration plan utilisateur:', error);
      // Continuer sans plan (sera trait√© comme free)
    }
  }
  next();
});

// =============================================================================
// üõ£Ô∏è ROUTES PRINCIPALES
// =============================================================================

// Route racine
app.get('/', (req, res) => {
  res.json({
    message: 'Bienvenue sur WolofDict API',
    version: process.env.API_VERSION || '1.0.0',
    status: 'operational',
    features: {
      dictionary: 'Dictionnaire collaboratif wolof',
      learning: 'Outils d\'apprentissage adaptatifs',
      community: 'Communaut√© et forum actifs',
      business: 'Mod√®le freemium avec plans premium',
      ai: 'Intelligence artificielle wolof native'
    },
    links: {
      api: '/api/v1',
      documentation: '/docs',
      health: '/api/v1/health',
      plans: '/api/v1/plans',
      signup: '/api/v1/auth/register'
    }
  });
});

// Montage des routes API
app.use('/api/v1', intelligentRateLimit, routes);

// =============================================================================
// üìÅ FICHIERS STATIQUES
// =============================================================================

// Servir les fichiers statiques (images, audio, etc.)
app.use('/static', express.static(path.join(__dirname, '../public'), {
  maxAge: process.env.NODE_ENV === 'production' ? '1y' : '1h',
  etag: true,
  lastModified: true
}));

// Documentation API (si disponible)
if (process.env.NODE_ENV === 'development') {
  app.use('/docs', express.static(path.join(__dirname, '../docs')));
}

// =============================================================================
// üéØ ROUTES SP√âCIALES
// =============================================================================

// Favicon
app.get('/favicon.ico', (req, res) => {
  res.status(204).end();
});

// Robots.txt
app.get('/robots.txt', (req, res) => {
  res.type('text/plain');
  res.send(`User-agent: *
${process.env.NODE_ENV === 'production' ? 'Allow: /' : 'Disallow: /'}
Sitemap: https://wolofdict.com/sitemap.xml`);
});

// =============================================================================
// üîç MONITORING ET M√âTRIQUES
// =============================================================================

// Endpoint pour m√©triques Prometheus (si configur√©)
if (process.env.ENABLE_METRICS === 'true') {
  const prometheus = require('prom-client');
  
  // M√©triques par d√©faut
  const register = new prometheus.Registry();
  prometheus.collectDefaultMetrics({ register });
  
  // M√©triques personnalis√©es
  const httpRequestDuration = new prometheus.Histogram({
    name: 'http_request_duration_seconds',
    help: 'Duration of HTTP requests in seconds',
    labelNames: ['method', 'route', 'status_code', 'user_plan'],
    buckets: [0.1, 0.5, 1, 2, 5]
  });
  
  const activeUsers = new prometheus.Gauge({
    name: 'active_users_total',
    help: 'Number of active users by plan',
    labelNames: ['plan']
  });
  
  register.registerMetric(httpRequestDuration);
  register.registerMetric(activeUsers);
  
  // Middleware pour collecter les m√©triques
  app.use((req, res, next) => {
    const start = Date.now();
    
    res.on('finish', () => {
      const duration = (Date.now() - start) / 1000;
      httpRequestDuration
        .labels(req.method, req.route?.path || req.path, res.statusCode, req.user?.plan?.slug || 'anonymous')
        .observe(duration);
    });
    
    next();
  });
  
  // Endpoint m√©triques
  app.get('/metrics', (req, res) => {
    res.set('Content-Type', register.contentType);
    res.end(register.metrics());
  });
}

// =============================================================================
// üè• HEALTH CHECKS
// =============================================================================

// Health check simple
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Health check d√©taill√©
app.get('/health/detailed', async (req, res) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    services: {}
  };

  try {
    // Test base de donn√©es
    await sequelize.authenticate();
    health.services.database = 'healthy';
  } catch (error) {
    health.services.database = 'unhealthy';
    health.status = 'degraded';
  }

  try {
    // Test Redis
    if (process.env.REDIS_URL) {
      await RedisService.ping();
      health.services.redis = 'healthy';
    } else {
      health.services.redis = 'disabled';
    }
  } catch (error) {
    health.services.redis = 'unhealthy';
    health.status = 'degraded';
  }

  // Test services externes
  health.services.stripe = process.env.STRIPE_SECRET_KEY ? 'configured' : 'disabled';
  health.services.paypal = process.env.PAYPAL_CLIENT_ID ? 'configured' : 'disabled';
  health.services.email = process.env.SMTP_HOST ? 'configured' : 'disabled';

  res.status(health.status === 'healthy' ? 200 : 503).json(health);
});

// =============================================================================
// üö´ GESTION D'ERREURS
// =============================================================================

// Middleware pour routes non trouv√©es
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Route non trouv√©e',
    message: `La route ${req.method} ${req.originalUrl} n'existe pas`,
    suggestions: [
      'V√©rifiez l\'URL demand√©e',
      'Consultez la documentation API √† /docs',
      'Utilisez /api/v1 pour les endpoints API'
    ],
    links: {
      api: '/api/v1',
      documentation: '/docs',
      health: '/health'
    }
  });
});

// Middleware de gestion d'erreurs global
app.use((err, req, res, next) => {
  logger.error('Erreur application:', {
    error: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    user: req.user?.id || 'anonymous',
    ip: req.ip
  });

  // Erreurs sp√©cifiques √† l'application
  if (err.name === 'SequelizeValidationError') {
    return res.status(400).json({
      error: 'Erreur de validation',
      details: err.errors.map(e => ({
        field: e.path,
        message: e.message,
        value: e.value
      }))
    });
  }

  if (err.name === 'SequelizeUniqueConstraintError') {
    return res.status(409).json({
      error: 'Ressource d√©j√† existante',
      details: err.errors.map(e => ({
        field: e.path,
        message: 'Cette valeur est d√©j√† utilis√©e'
      }))
    });
  }

  if (err.name === 'SequelizeForeignKeyConstraintError') {
    return res.status(400).json({
      error: 'R√©f√©rence invalide',
      message: 'La ressource r√©f√©renc√©e n\'existe pas'
    });
  }

  // Erreurs de parsing JSON
  if (err.name === 'SyntaxError' && err.message.includes('JSON')) {
    return res.status(400).json({
      error: 'Format JSON invalide',
      message: 'V√©rifiez la syntaxe de votre requ√™te JSON'
    });
  }

  // Erreurs CORS
  if (err.message.includes('CORS')) {
    return res.status(403).json({
      error: 'Acc√®s refus√©',
      message: 'Origine non autoris√©e par CORS'
    });
  }

  // Erreurs business
  if (err.type === 'business_error') {
    return res.status(err.statusCode || 400).json({
      error: err.message,
      code: err.code,
      details: err.details
    });
  }

  // Erreur g√©n√©rique
  res.status(500).json({
    error: 'Erreur serveur interne',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Une erreur inattendue s\'est produite',
    request_id: req.id,
    timestamp: new Date().toISOString()
  });
});

// =============================================================================
// üî• GESTION PROCESSUS
// =============================================================================

// Gestion gracieuse de l'arr√™t
const gracefulShutdown = async (signal) => {
  logger.info(`Signal ${signal} re√ßu, arr√™t gracieux...`);
  
  try {
    // Fermer les connexions
    await sequelize.close();
    logger.info('‚úÖ Connexions base de donn√©es ferm√©es');
    
    if (process.env.REDIS_URL) {
      await RedisService.disconnect();
      logger.info('‚úÖ Connexion Redis ferm√©e');
    }
    
    logger.info('‚úÖ Arr√™t gracieux termin√©');
    process.exit(0);
  } catch (error) {
    logger.error('‚ùå Erreur lors de l\'arr√™t gracieux:', error);
    process.exit(1);
  }
};

// √âcouter les signaux d'arr√™t
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Gestion des erreurs non captur√©es
process.on('uncaughtException', (error) => {
  logger.error('Erreur non captur√©e:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Promesse rejet√©e non g√©r√©e:', { reason, promise });
  process.exit(1);
});

// =============================================================================
// üöÄ INITIALISATION ET D√âMARRAGE
// =============================================================================

// Fonction d'initialisation compl√®te
const initializeApp = async () => {
  try {
    logger.info('üåç Initialisation de WolofDict API...');
    
    // Initialisation des services
    const dbConnected = await initializeDatabase();
    const redisConnected = await initializeRedis();
    const paymentsInitialized = await initializePaymentServices();
    const emailInitialized = await initializeEmailService();
    
    // V√©rification des services critiques
    if (!dbConnected) {
      throw new Error('Impossible de se connecter √† la base de donn√©es');
    }
    
    logger.info('‚úÖ Initialisation termin√©e avec succ√®s');
    
    return {
      database: dbConnected,
      redis: redisConnected,
      payments: paymentsInitialized,
      email: emailInitialized
    };
  } catch (error) {
    logger.error('‚ùå Erreur lors de l\'initialisation:', error);
    throw error;
  }
};

// D√©marrage du serveur
const startServer = async () => {
  try {
    // Initialiser l'application
    const services = await initializeApp();
    
    // D√©marrer le serveur HTTP
    const PORT = process.env.PORT || 3000;
    const server = app.listen(PORT, () => {
      logger.info(`üöÄ Serveur WolofDict d√©marr√© sur le port ${PORT}`);
      logger.info(`üì° API disponible sur http://localhost:${PORT}/api/v1`);
      logger.info(`üìö Documentation sur http://localhost:${PORT}/docs`);
      logger.info(`üîß Environnement: ${process.env.NODE_ENV || 'development'}`);
      logger.info(`üí∞ Services business: ${services.payments ? 'activ√©s' : 'd√©sactiv√©s'}`);
    });
    
    // Configuration du serveur
    server.timeout = 30000; // 30 secondes
    server.keepAliveTimeout = 5000; // 5 secondes
    server.headersTimeout = 10000; // 10 secondes
    
    return server;
  } catch (error) {
    logger.error('‚ùå Erreur lors du d√©marrage:', error);
    process.exit(1);
  }
};

// =============================================================================
// üéØ EXPORT
// =============================================================================

// D√©marrer le serveur si ce fichier est ex√©cut√© directement
if (require.main === module) {
  startServer().catch(error => {
    logger.error('Erreur fatale:', error);
    process.exit(1);
  });
}

// Export pour tests et autres utilisations
module.exports = {
  app,
  startServer,
  initializeApp
};